<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>不是在改BUG，就是在改BUG的路上 - 容器 - 隔离与限制</title>

      
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.kiyoko.io/atom.xml">
      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="https://blog.kiyoko.io/site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">三天打鱼</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.kiyoko.io">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;blog.kiyoko.io">三天打鱼</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.kiyoko.io">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#jin-cheng" class="toc-link">进程</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#chuang-jian-rong-qi" class="toc-link">创建容器</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#namespace" class="toc-link">Namespace</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://blog.kiyoko.io/namespace-and-cgroup/#ru-he-shi-yong-namespace-ji-zhu" class="toc-link">如何使用 Namespace 技术</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#cgroup" class="toc-link">Cgroup</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://blog.kiyoko.io/namespace-and-cgroup/#cgroup-in-action" class="toc-link">Cgroup In Action</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#cgroup-in-docker" class="toc-link">Cgroup in Docker</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.kiyoko.io/namespace-and-cgroup/#can-kao-yue-du" class="toc-link">参考阅读</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;namespace-and-cgroup&#x2F;">容器 - 隔离与限制</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2020-08-17</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>容器技术的本质是一种沙盒技术，可以将应用及相关配置、脚本 <strong>装</strong> 到一个 <strong>箱子</strong> 中。这样，多个应用之间就会因为有了边界而避免相互干扰。并且，应用被装进箱子后，也便于移动。</p>
<h2 id="jin-cheng">进程</h2>
<p>要实现一个程序，从一个文件读取两个整数，将计算结果写入到另一个文件中，则至少需要有三个文件:</p>
<ul>
<li>可执行文件</li>
<li>输入文件</li>
<li>输出文件</li>
</ul>
<p>由于计算机只认识 <code>0</code> 和 <code>1</code>，因此无论用哪种语言编写这段代码，最后这三个文件都需要通过某种方式翻译成二进制文件，才能在计算机操作系统中运行与使用。初始状态时，三个文件都存放在磁盘上。可执行文件被称作 <strong>程序</strong>，剩余两个文件是 <strong>数据</strong>。</p>
<p>要完成功能，需要在计算机上执行这个程序。</p>
<p>首先，操作系统将 <strong>程序</strong> 载入到内存中，表现为指令序列。在执行过程中，当执行到从文件加载输入数据的指令时，操作系统控制存储控制器完成将数据从磁盘载入到内存。之后，操作系统读取到计算加法的指令时，通过 <code>CPU</code>、寄存器与内存的共同协作完成加法计算将计算结果暂存在内存中。最后，执行将结果保存到文件的指令时，操作系统会通过存储控制器，将内存中的结果写入到磁盘上。同时，操作系统中还需要维护其他状态，辅助这一过程顺利进行。</p>
<p>在操作系统中，将上述过程所涉及到的总和称作: 进程。</p>
<p>而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个 <strong>边界</strong>。</p>
<p>对于 <code>Docker</code> 等大多数 <code>Linux</code> 容器来说，使用 <code>cgroups</code> 技术来制造约束，使用 <code>namespace</code> 技术来修改进程视图。</p>
<h2 id="chuang-jian-rong-qi">创建容器</h2>
<p>首先创建一个容器:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> docker run</span><span style="color:#bf616a;"> --help
</span><span style="color:#bf616a;">Usage:</span><span>  docker run </span><span style="color:#b48ead;">[</span><span>OPTIONS</span><span style="color:#b48ead;">]</span><span> IMAGE </span><span style="color:#b48ead;">[</span><span>COMMAND</span><span style="color:#b48ead;">] [</span><span>ARG...</span><span style="color:#b48ead;">]
</span><span>
</span><span style="color:#bf616a;">$</span><span> docker run</span><span style="color:#bf616a;"> -it</span><span> busybox /bin/sh
</span><span style="color:#bf616a;">Unable</span><span> to find image &#39;</span><span style="color:#a3be8c;">busybox:latest</span><span>&#39; locally
</span><span style="color:#bf616a;">latest:</span><span> Pulling from library/busybox
</span><span style="color:#bf616a;">91f30d776fb2:</span><span> Pull complete
</span><span style="color:#bf616a;">Digest:</span><span> sha256:9ddee63a712cea977267342e8750ecbc60d3aab25f04ceacfa795e6fce341793
</span><span style="color:#bf616a;">Status:</span><span> Downloaded newer image for busybox:latest
</span><span style="color:#bf616a;">/ </span><span style="color:#65737e;">#
</span></code></pre>
<p>参数 <code>-it</code> 的含义是</p>
<ul>
<li><strong>-i</strong>: --interactive     Keep STDIN open even if not attached</li>
<li><strong>-t</strong>, --tty             Allocate a pseudo-TTY</li>
</ul>
<p>结果就是，在操作系统中创建了一个容器，该容器中执行的程序为 <code>/bin/sh</code>。并且，在容器启动之后，申请了一个随机的 <code>tty</code>，使用交互方式访问这个容器。</p>
<p>现在，执行 <code>ps</code> 指令，结果真是 <strong>Amazing</strong> 啊:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">/ </span><span style="color:#65737e;"># ps
</span><span style="color:#bf616a;">PID</span><span>   USER     TIME  COMMAND
</span><span>    </span><span style="color:#bf616a;">1</span><span> root      0:00 /bin/sh
</span><span>    </span><span style="color:#bf616a;">6</span><span> root      0:00 ps
</span></code></pre>
<p>在创建容器时指定的 <code>/bin/sh</code> 进程，竟然就是容器内部的第一个进程<code>(pid=1)</code>，并且，这个容器内只有两个进程正在运行中，另一个进程是正在执行的 <code>ps</code> 指令。</p>
<p>而这正是 <code>namespace</code> 技术的神奇之处。</p>
<h2 id="namespace">Namespace</h2>
<p>首先，通过 <code>manpages</code> 对 <code>namespace</code> 有一个初步的了解:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> man namespaces
</span><span style="color:#bf616a;">NAMESPACES</span><span>(7)                       </span><span style="color:#bf616a;">Linux</span><span> Programmer&#39;</span><span style="color:#a3be8c;">s Manual                       NAMESPACES(7)
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">NAME
</span><span style="color:#a3be8c;">       namespaces - overview of Linux namespaces
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">DESCRIPTION
</span><span style="color:#a3be8c;">       A namespace wraps a global system resource in an abstraction that makes it appear to the processes
</span><span style="color:#a3be8c;">       within the namespace that they have their own isolated instance of the global resource. Changes to
</span><span style="color:#a3be8c;">       the global resource are visible to other processes that are members of the namespace, but are
</span><span style="color:#a3be8c;">       invisible to other processes. One use of namespaces is to implement containers.
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       This page provides pointers to information on the various namespace types, describes the associated
</span><span style="color:#a3be8c;">      /proc files, and summarizes the APIs for working with namespaces.
</span><span style="color:#a3be8c;">       ...
</span></code></pre>
<p>总的来说，<code>Linux Namespace</code> 提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的 <code>Namespace</code> 中，来实现资源隔离的目的。不同 <code>Namespace</code> 的程序，可以享有一份独立的系统资源。目前 <code>Linux</code> 中提供了以下几种系统资源的隔离机制：</p>
<table><thead><tr><th align="left">Namespace</th><th align="left">Flag</th><th align="left">Page</th><th align="left">Isolates</th></tr></thead><tbody>
<tr><td align="left">Cgroup</td><td align="left">CLONE_NEWCGROUP</td><td align="left">cgroup_namespaces(7)</td><td align="left">Cgroup root directory</td></tr>
<tr><td align="left">IPC</td><td align="left">CLONE_NEWIPC</td><td align="left">ipc_namespaces(7)</td><td align="left">System V IPC, POSIX message queues</td></tr>
<tr><td align="left">Network</td><td align="left">CLONE_NEWNET</td><td align="left">network_namespaces(7)</td><td align="left">Network devices, stacks, ports, etc.</td></tr>
<tr><td align="left">Mount</td><td align="left">CLONE_NEWNS</td><td align="left">mount_namespaces(7)</td><td align="left">Mount points</td></tr>
<tr><td align="left">PID</td><td align="left">CLONE_NEWPID</td><td align="left">pid_namespaces(7)</td><td align="left">Process IDs</td></tr>
<tr><td align="left">Time</td><td align="left">CLONE_NEWTIME</td><td align="left">time_namespaces(7)</td><td align="left">Boot and monotonic clocks</td></tr>
<tr><td align="left">User</td><td align="left">CLONE_NEWUSER</td><td align="left">user_namespaces(7)</td><td align="left">User and group IDs</td></tr>
<tr><td align="left">UTS</td><td align="left">CLONE_NEWUTS</td><td align="left">uts_namespaces(7)</td><td align="left">Hostname and NIS domain name</td></tr>
</tbody></table>
<h3 id="ru-he-shi-yong-namespace-ji-zhu">如何使用 Namespace 技术</h3>
<p>以 <code>PID Namespace</code> 为例，简单说明如何在编程中使用这种技术。</p>
<p><code>Linux</code> 实现 <code>Namespace</code> 机制的方式，是通过在创建进程的时候，传入特定的选项。更具体一些，就是在调用</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> man 2 clone
</span><span style="color:#bf616a;">CLONE</span><span>(2)                            </span><span style="color:#bf616a;">Linux</span><span> Programmer&#39;</span><span style="color:#a3be8c;">s Manual                           CLONE(2)
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">NAME
</span><span style="color:#a3be8c;">       clone, __clone2, clone3 - create a child process
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">SYNOPSIS
</span><span style="color:#a3be8c;">       /* Prototype for the glibc wrapper function */
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       #define _GNU_SOURCE
</span><span style="color:#a3be8c;">       #include &lt;sched.h&gt;
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">       int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
</span><span style="color:#a3be8c;">                 /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
</span></code></pre>
<p>系统调用时，传入对应的 <code>Flag</code> 作为参数 <code>flag</code> 的值。比如:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int</span><span> pid = </span><span style="color:#bf616a;">clone</span><span>(main_function, stack_size, SIGCHLD, </span><span style="color:#d08770;">NULL</span><span>);
</span></code></pre>
<p>就会创建一个新的进程，并且返回它的进程号 <code>pid</code>。</p>
<p>如果，同时指定 <code>CLONE_NEWPID</code> 参数:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int</span><span> pid = </span><span style="color:#bf616a;">clone</span><span>(main_function, stack_size, CLONE_NEWPID | SIGCHLD, </span><span style="color:#d08770;">NULL</span><span>);
</span></code></pre>
<p>新创建进程将会 <strong>看到</strong> 一个全新的进程空间，在这个进程空间里，它的 <code>pid</code> 是 <code>1</code>。之所以说 <strong>看到</strong>，是因为这只是一个 <strong>障眼法</strong>，在宿主机真实的进程空间里，这个进程的 <code>pid</code> 还是真实的数值，比如 <code>404</code>。</p>
<p>如果多次执行上面的 <code>clone()</code> 调用，就会创建多个 <code>PID Namespace</code>，而每个 <code>Namespace</code> 里的应用进程都会认为自己是当前容器里的 <strong>第 1 号进程</strong>，它们既看不到宿主机里真正的进程空间，也看不到其他 <code>PID Namespace</code> 里的具体情况。</p>
<p>而其他的几种 <code>Namespace</code>，在写法上与 <code>PID Namespace</code> 是相同的，区别只在于目的不同。</p>
<p>所以，<code>Docker</code> 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 <code>Namespace</code> 参数。这样，容器就只能 <strong>看到</strong> 当前 <code>Namespace</code> 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>
<p>本质仍旧是进程。因此，在之前出现过的虚拟机对比容器的图片中，才没有出现 <code>Docker</code> 的位置。因为，容器只是通过 <code>Namespace</code> 技术被隔离的进程，与其他进程一样，也是直接运行在宿主机操作系统之上的。<code>Docker</code> 只是充当了一个管理者的身份。</p>
<p><img src="/images/what-is-the-docker/virtualization-vs-containers.png" alt="virtualization-vs-containers" /></p>
<p>既然，虚拟机与容器是两种不同的技术，那么二者之间就应该有一些区别。</p>
<h4 id="rong-qi-de-you-shi">容器的优势</h4>
<h5 id="zhan-yong-zi-yuan-xiao">占用资源小</h5>
<p>容器占用的内存，要比同等功能的虚拟机占用的内存小，因为虚拟机本身也需要消耗一定的资源。比如，运行 <code>CentOS</code> 的 <code>KVM</code> 虚拟机至少需要 <code>100 ~ 200 MB</code> 的内存</p>
<h5 id="geng-hao-de-i-o-xing-neng">更好的 I/O 性能</h5>
<p>在参考阅读 <a href="https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf">An Updated Performance Comparison of Virtual Machines and Linux Containers</a> 中显示</p>
<ul>
<li>在随机读写场景中，无论是 <code>iops</code> 还是 <code>latency</code>，容器的性能都接近于物理机性能，远好于 <code>KVM</code> 虚拟机</li>
<li>在顺序读写场景中，容器的性能基本与物理机性能，略好于 <code>KVM</code> 虚拟机</li>
<li>在 <code>host network</code> 场景中，容器的性能接近于物理机的性能，好于 <code>KVM</code> 虚拟机</li>
<li>在 <code>nat network</code> 场景中，容器的性能略逊于 <code>KVM</code> 虚拟机，但差别不大</li>
</ul>
<p>总的来说，容器的 <code>I/O</code> 性能优于 <code>KVM</code> 虚拟机</p>
<h4 id="rong-qi-de-lie-shi">容器的劣势</h4>
<h5 id="ping-tai-yi-lai-xing">平台依赖性</h5>
<ul>
<li>尽管，可以通过 <code>Mount Namespace</code> 的方式挂起与宿主机不同的 <code>Linux</code> 发行版，但容器中进程使用的内核依然是宿主机的内核。
<ul>
<li>因此 <code>Windows</code> 耗费了那么长的时间才对容器技术有了比较好的支持。</li>
<li>同样，也无法在低版本内核的宿主机上运行高版本内核的容器。</li>
</ul>
</li>
</ul>
<h5 id="you-xian-de-ge-chi">有限的隔离</h5>
<p>部分资源无法被隔离，比如 <strong>时间</strong>。</p>
<p>如果在容器中调用 <code>settimeofday(2)</code> 系统调用修改系统时间，会导致宿主机系统的时间被修改，这显然是一个很可怕的事情。因此，在使用容器的时候必须要了解 <strong>什么能做，什么不能做</strong>。</p>
<h2 id="cgroup">Cgroup</h2>
<p><code>Namespace</code> 技术的作用是隔离进程，但只有隔离是不够的。虽然，容器内的进程无法感知到其他运行在宿主机上的进程或容器，但从操作系统的角度而言，所有的进程与容器都是平等的地位。这就意味着，虽然容器是一个独立的小空间，但其可用的资源仍旧与其他进程之间有着竞争的关系。</p>
<p>因此，就需要用到 <code>Cgroup</code> 技术的帮助了。</p>
<p><code>Cgroup</code> 全称为 <code>Control Group</code>，用途是限制一个进程组能够使用的资源上限，包括 <code>CPU</code>、<code>MEM</code>、<code>DISK</code>、<code>NETWORK</code> 等。</p>
<h3 id="cgroup-in-action">Cgroup In Action</h3>
<p>在 <code>Linux</code> 中 <code>Everything is a file</code>，因此，操作 <code>Cgroup</code> 的途径也是通过文件系统。</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> mount</span><span style="color:#bf616a;"> -t</span><span> cgroup
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
</span><span style="color:#bf616a;">cgroup</span><span> on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
</span></code></pre>
<p>可以看到，<code>Cgroup</code> 是一系列定义在 <code>/sys/fs/cgroup/</code> 目录下的各种文件或文件夹。每一个文件夹都被用来限制某一种特定的资源。以 <code>cpu</code> 资源为例:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> ls /sys/fs/cgroup/cpu
</span><span style="color:#bf616a;">000-metadata</span><span>  cgroup.clone_children  cpu.cfs_period_us  cpu.rt_runtime_us  docker    notify_on_release  systemreserved
</span><span style="color:#bf616a;">001-binfmt</span><span>    cgroup.procs           cpu.cfs_quota_us   cpu.shares         kmsg      podruntime         tasks
</span><span style="color:#bf616a;">002-bridge</span><span>    cgroup.sane_behavior   cpu.rt_period_us   cpu.stat           kubepods  release_agent
</span></code></pre>
<p>列举了限制 <code>cpu</code> 资源的各种参数选项。</p>
<p>使用 <code>Cgroup</code> 的方式非常简单，在对应的资源目录下面创建一个目录，比如:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> sudo mkdir</span><span style="color:#bf616a;"> -p</span><span> /sys/fs/cgroup/cpu/container
</span><span>
</span><span style="color:#bf616a;">$</span><span> ls /sys/fs/cgroup/cpu/container
</span><span style="color:#bf616a;">cgroup.clone_children</span><span>  cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
</span><span style="color:#bf616a;">cgroup.procs</span><span>           cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</span></code></pre>
<p>这个目录被称作 <strong>控制组</strong>，<code>Linux</code> 会在控制组下自动创建各种资源限制文件。</p>
<p>然后，在后台执行脚本:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> while : ; </span><span style="color:#b48ead;">do </span><span style="color:#96b5b4;">: </span><span>; </span><span style="color:#b48ead;">done </span><span>&amp;
</span><span style="color:#bf616a;">[1]</span><span> 12555
</span></code></pre>
<p>显然，这是一个死循环进程，会占用 <code>100%</code> 的 <code>CPU</code>。使用 <code>top</code> 指令，也可以确认确实使用了 <code>100%</code> 的 <code>CPU</code>。</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> top</span><span style="color:#bf616a;"> -p</span><span> 12555
</span><span style="color:#bf616a;">top</span><span> - 21:00:26 up  4:43,  0 users,  load average: 0.66, 0.66, 0.56
</span><span style="color:#bf616a;">Tasks:</span><span>   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
</span><span>%</span><span style="color:#bf616a;">Cpu</span><span>(s)</span><span style="color:#96b5b4;">:</span><span>  0.0 us,  2.5 sy,  3.7 ni, 93.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</span><span style="color:#bf616a;">MiB</span><span> Mem :   7958.1 total,   5885.9 free,    539.2 used,   1533.0 buff/cache
</span><span style="color:#bf616a;">MiB</span><span> Swap:  16384.0 total,  16384.0 free,      0.0 used.   7183.5 avail Mem
</span><span>
</span><span>  </span><span style="color:#bf616a;">PID</span><span> USER      PR  NI    VIRT    RES    SHR S  %</span><span style="color:#bf616a;">CPU  </span><span>%</span><span style="color:#bf616a;">MEM</span><span>     TIME+ COMMAND
</span><span style="color:#bf616a;">12555</span><span> diviner+  25   5   13576   4816      0 R 100.0   0.1   0:46.30 zsh
</span></code></pre>
<p>接下来，是时候展现 <code>Cgroup</code> 的魔法了。首先，查看两个接下来要使用的关键文件:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
</span><span style="color:#bf616a;">-1
</span><span style="color:#bf616a;">$</span><span> cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us
</span><span style="color:#bf616a;">100000
</span></code></pre>
<ul>
<li><strong>cfs_period_us</strong>: 资源组获取资源的时间周期，单位微妙</li>
<li><strong>cfs_quota_us</strong>: 在获取资源时间周期内获得资源的时间，单位微妙</li>
</ul>
<p>所以 <code>usage = cfs_quota_us / cfs_period_us</code>。</p>
<p>为了验证这一点，尝试将进程的 <code>CPU</code> 使用率控制在 <code>20%</code>。</p>
<p>首先，根据上面推测的公式，因为 <code>cfs_period_us = 100000</code>，所以应该修改 <code>cfs_quota_us</code>:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#96b5b4;">echo</span><span> 20000 | </span><span style="color:#bf616a;">sudo</span><span> tee /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
</span></code></pre>
<p>但这还不够，还需要将被限制的进程的 <code>PID</code> 写入到 <strong>控制组</strong> <code>container</code> 的 <code>tasks</code>:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#96b5b4;">echo</span><span> 12555 | </span><span style="color:#bf616a;">sudo</span><span> tee /sys/fs/cgroup/cpu/container/tasks
</span></code></pre>
<p>然后使用 <code>top</code> 查看:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">top</span><span> - 21:09:11 up  4:52,  0 users,  load average: 0.41, 0.76, 0.70
</span><span style="color:#bf616a;">Tasks:</span><span>   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
</span><span>%</span><span style="color:#bf616a;">Cpu</span><span>(s)</span><span style="color:#96b5b4;">:</span><span>  0.0 us,  0.8 sy,  0.9 ni, 98.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</span><span style="color:#bf616a;">MiB</span><span> Mem :   7958.1 total,   5883.8 free,    541.1 used,   1533.1 buff/cache
</span><span style="color:#bf616a;">MiB</span><span> Swap:  16384.0 total,  16384.0 free,      0.0 used.   7181.6 avail Mem
</span><span>
</span><span>  </span><span style="color:#bf616a;">PID</span><span> USER      PR  NI    VIRT    RES    SHR S  %</span><span style="color:#bf616a;">CPU  </span><span>%</span><span style="color:#bf616a;">MEM</span><span>     TIME+ COMMAND
</span><span style="color:#bf616a;">12555</span><span> diviner+  25   5   13576   4816      0 R  20.0   0.1   8:17.25 zsh
</span></code></pre>
<p><code>Linux Cgroups</code> 的设计还是比较易用的，可以简单地理解为，一个子系统目录加上一组资源限制文件的组合。而对于 <code>Docker</code> 等 <code>Linux</code> 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个<strong>控制组</strong> (即创建一个新目录)，然后在启动容器进程之后，把这个进程的 <code>PID</code> 填写到对应控制组的 <code>tasks</code> 文件中就可以了。</p>
<h2 id="cgroup-in-docker">Cgroup in Docker</h2>
<p>在通过 <code>Docker</code> 启动容器的时候，也可以限制 <code>cpu</code> 使用率:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> docker run</span><span style="color:#bf616a;"> -it --cpu-period</span><span>=100000</span><span style="color:#bf616a;"> --cpu-quota</span><span>=20000 ubuntu /bin/bash
</span><span style="color:#bf616a;">611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4
</span></code></pre>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span> cat /sys/fs/cgroup/cpu/docker/611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4/cpu.cfs_period_us
</span><span style="color:#bf616a;">100000
</span><span>
</span><span style="color:#bf616a;">$</span><span> cat /sys/fs/cgroup/cpu/docker/611f8f2c0c7613c2f3f3964e7dc3dbe407c74689e376736e34d7fe4735ec95d4/cpu.cfs_quota_us
</span><span style="color:#bf616a;">20000
</span></code></pre>
<p>此时，这个容器最多只能使用 <code>20%</code> 的 <code>CPU</code>。</p>
<h2 id="can-kao-yue-du">参考阅读</h2>
<ul>
<li><a href="https://dominoweb.draco.res.ibm.com/reports/rc25482.pdf">An Updated Performance Comparison of Virtual Machines and Linux Containers</a></li>
</ul>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://blog.kiyoko.io/tags/container/">#container</a>
                    
                        <a href="https://blog.kiyoko.io/tags/namespace/">#namespace</a>
                    
                        <a href="https://blog.kiyoko.io/tags/cgroup/">#cgroup</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;what-is-the-docker&#x2F;">‹ Docker - 概述</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;blog.kiyoko.io&#x2F;docker-image&#x2F;">容器 - 深入理解镜像 ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://blog.kiyoko.io/even.js" ></script>
      
    </body>

</html>
